---
layout: post
title: High Resolution performance timer
date: '2014-12-21T13:01:00.002-08:00'
author: Glen Berseth
summary: I recently stumbled across this issue because I was trying to compile some code on an ARM based computer. There was code in the program I wanted to compile that uses assembly! I am not going to get into the details over which method might be faster or has higher resolution. From what I have learned this is the most compact and portable code to use if you want a high resolution counter that can be used for something like performance profiling.
tags: Linux, C++, HighResolutionTimer
modified_time: '2014-12-21T13:02:09.403-08:00'
blogger_id: tag:blogger.com,1999:blog-2030049895335802245.post-2778979455722046450
blogger_orig_url: http://fracturedplane.blogspot.com/2014/12/high-resolution-performance-timer.html
---

I recently stumbled across this issue because I was trying to compile some code on an ARM based computer. There was code in the program I wanted to compile that uses assembly! I am not going to get into the details over which method might be faster or has higher resolution. From what I have learned this is the most compact and portable code to use if you want a high resolution counter that can be used for something like performance profiling.<br /><br /><br />This was the original code that was causing the issue. This code depends on the x86 instruction set.<br /><pre class="prettyprint"><code><br />#ifdef _WIN32</code></pre><pre class="prettyprint"><code>   unsigned long long tick;<br />   QueryPerformanceCounter((LARGE_INTEGER *)&amp;tick); // works great on Windows ONLY<br />   return tick;</code></pre><pre class="prettyprint"><code>#else</code></pre><pre class="prettyprint"><code>&nbsp;uint32_t hi, lo;<br />   __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi)); // Works well on x86 only<br />   return ( (uint64_t)lo)|( (uint64_t)hi)&lt;&lt; 32 );</code></pre><pre class="prettyprint"><code>#endif</code></pre><pre class="prettyprint"><code><br /></code></pre><br /><br />Thanks to improvements on the POSIX based <br /><pre><b>int clock_gettime(clockid_t </b><i>clk_id</i><b>, struct timespec *</b><i>tp</i><b>);</b></pre><pre><b>&nbsp;</b></pre>We can replace our not portable assembly code for our easy to use clock_gettime code like so<br /><br /><br /><pre class="prettyprint"><code><br />#ifdef _WIN32</code></pre><pre class="prettyprint"><code>   unsigned long long tick;<br />   QueryPerformanceCounter((LARGE_INTEGER *)&amp;tick); // works great on Windows ONLY<br />   return tick;</code></pre><pre class="prettyprint"><code>#else</code></pre><pre class="prettyprint"><code>&nbsp;  timespec timeInfo;<br />   clock_gettime(CLOCK_MONOTONIC_RAW, &amp;timeInfo); // nanosecond resolution<br />   unsigned long long int nanosecs = ((unsigned long long)timeInfo.tv_sec)*1000000000  +&nbsp;</code></pre><pre class="prettyprint"><code>&nbsp;                      ((unsigned long long)timeInfo.tv_nsec);<br />   return nanosecs;</code></pre><pre class="prettyprint"><code>#endif</code></pre><br />Best of luck.<br /><br />References:<br /><ol><li>http://man7.org/linux/man-pages/man2/clock_gettime.2.html</li><li>http://tdistler.com/2010/06/27/high-performance-timing-on-linux-windows</li><li>http://en.wikipedia.org/wiki/High_Precision_Event_Timer</li></ol>