---
layout: post
title: IndiGolog Basics
date: '2013-02-22T20:42:00.002-08:00'
author: Glen B
tags: 
modified_time: '2013-02-22T20:42:31.141-08:00'
blogger_id: tag:blogger.com,1999:blog-2030049895335802245.post-8587021221495967858
blogger_orig_url: http://fracturedplane.blogspot.com/2013/02/indigolog-basics.html
---

This is a guide on the steps I took set-up a IndiGolog Program.<br /><br />I prefer to divide up the sections of an IndiGolog program into different files. The different sections of an IndiGolog program are:<br /><ol><li>Exogenous Actions</li><ol><li>Contains the code to handle exogenous actions from then environment. </li></ol><li>Fluents</li><ol><li>Fluents handle the current state of the environment relative to the agent. </li></ol><li>Initial Conditions</li><ol><li>The initial conditions of the agent </li></ol><li>Primitive Actions</li><ol><li>The primitive actions of the agent. These are the lowest level actions that the agent can make </li></ol><li>Procedures&nbsp;</li><ol><li>The procedures of the agents. Procedures are sequences of primitive actions that are created from knowledge of the Agent.</li></ol></ol><br />The exogenous actions code can be small but will grow depending design. For a basic set of exogenous actions this short list could be used. <br /><br /><br /><pre class="prettyprint"><code class="language-bash"><br />/* exog_action(reached(Location)).<br />&nbsp;&nbsp;&nbsp; Lets the Agent know when it has fully arived at a location it was navigating<br />to.<br />*/<br />exog_action(reached(_)).<br /><br />/*<br />&nbsp;&nbsp;&nbsp; catch all to make sure system does not crash<br />*/<br />exog_action(_).<br /></code></pre><br />Fluents are one of the most important parts of the Agents design. fluents are supposed to evolve according to actions that occur. Then these fluents can be used in procedures to make good choices or in any conditions.<br /><br /><pre class="prettyprint"><code class="language-bash"><br />% Used to keep track of the state of the Entity<br />% When the controlled Entity dies this will be set to false.<br />rel_fluent(alive).<br />causes_val(died, alive, false, true) :-<br />&nbsp;&nbsp;&nbsp; nl, write('Entity died'), nl.<br /></code></pre><br /><br />There are different kinds of fluents in IndiGolog rel_fluent and fun_fluent which I believe stand for relational fluent and functional fluent. I am not totally sure what the difference is...<br /><br /><pre class="prettyprint"><code class="language-bash"><br />% Will be used to keep track of the inventory of the Entity.<br />/*&nbsp;&nbsp;&nbsp; hasItem(item, player)<br />&nbsp;&nbsp;&nbsp; Use to keep track of the many game items and players with an<br />&nbsp;&nbsp;&nbsp; association of players with items.<br />*/<br />rel_fluent(hasItem(_,_)).<br />causes_val(pickup(Item,Player), hasItem(Item, Player), true, true).<br />causes_val(drop(Item,Player), hasItem(Item, Player), false, hasItem(Item, Player)).</code></pre><pre class="prettyprint"><code class="language-bash">&nbsp;</code></pre><pre class="prettyprint"><code class="language-bash">% -- causes_true(action,fluent,cond)<br />%          when cond holds, doing act causes relational fluent to hold<br />% doing this because predicate does not exist<br />% these need to be defined so that the causes_val will work properly because it is<br />% defined to use these two predicates in ../../Eval/evalbat.pl<br />% because of relational fluents<br />causes_true(action,fluent,false).<br /><br />causes_false(action, fluent, false).<br /></code></pre><br /><br />The initial conditions describe the state of the agents world when the program is started. This section can also be use to test the agent by adjusting initial conditions to inspect of the agent still preforms a reasonable set of actions.<code>&nbsp;</code><br /><br />Some predicates can be defined to help solidify the definition of initial conditions<br /><br /><br /><pre class="prettyprint"><code class="language-bash"><br />enemies([valerie, will, amy, player]).<br />friends([glensnemesis, heather, jim, bob, self]).<br />isEnemy(Player) :- domain(Player, enemies).<br />isFriend(Player) :- domain(Player, friends).<br />isPlayer(Player) :- isFriend(Player); isEnemy(Player).&nbsp;</code></pre><br /><br /><br /><pre class="prettyprint"><code class="language-bash"><br />%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br />%% Initial conditions<br />%% Initial values of fluents<br />%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br />initially(alive, true).<br />initially(hasItem(Item, Player), false) :-<br />&nbsp;&nbsp;&nbsp; isItem(Item),<br />&nbsp;&nbsp;&nbsp; isPlayer(Player).<br /><br /><br />initially(name, none).<br /></code></pre><br /><br /><br /><code>Primitive actions as said are the lowest actions that an Agent can take. The reason for the primitive actions are to define what is a acceptable action and to define when a particular action is indeed possible in a given situation.</code><br /><br /><pre class="prettyprint"><code class="language-bash"><br />%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br />% Primitive actions<br />%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br /><br />prim_action(die).<br /> prim_action(look(_)).<br /><br /><br />prim_action(startgoto(_)).<br /><br /></code></pre><br /><br />These are preconditions for the primitive actions. These are very important in a search so the search knows that the actions it selects are valid in the situation thet are selected for.<br /><br /><pre class="prettyprint"><code class="language-bash"><br />/*<br />&nbsp;&nbsp;&nbsp; Preconditions for primitive actions<br />*/<br /><br />poss(check_for_enemy, true).<br /><br />poss(look(_), true).<br /><br /><br /><br /><code>poss(startgoto(Location), location(Location)).&nbsp;<br /></code></code></pre><br /><br /><br />Now procedures are more involved than any of the other pieces of code but they are heavily depandant on them. Some can be as simple as,<br /><br /><pre class="prettyprint"><code class="language-bash"><br />proc(defendCapturer,<br />&nbsp;&nbsp;&nbsp; pi(teammate, <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [?(hasItem(enemyflag, teammate)), <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; defend(teammate)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ]<br />&nbsp;&nbsp;&nbsp; )<br />).<br /></code></pre><br /><br />This procedure is to defend the capturer (comes form an agent written to play capture the flag). Essentially it uses pi (pronounced "pick") to choose the teammate of the agent for which the condition hasItem(enemyflag, teammate) is true. Choose the teammate that has the enemyflag and defend that teammate. Pretty awesome for really only 4 lines of code.&nbsp; <br /><br />For the functionality of the IndiGolog agent this line needs to be added and is very importand<br /><br /><pre class="prettyprint"><code class="language-bash"><br />% THIS IS THE MAIN PROCEDURE FOR INDIGOLOG<br />proc(main,&nbsp; mainControl(N)) :- controller(N), !.<br /></code></pre><br /><br />When the "main" method is called it will try all of controllers defined for the agent.&nbsp; <br /><br />Some examples<br /><br /><pre class="prettyprint"><code class="language-bash"><br />/*<br /><br />&nbsp;&nbsp;&nbsp; This procedures includes parts of the last. This one will loop while<br /><br />&nbsp;&nbsp;&nbsp; the Entity is still alive. It will prioritize these action states<br /><br />&nbsp;&nbsp;&nbsp; 1. If there is enemyContact engage and attack that enemy.<br /><br />&nbsp;&nbsp;&nbsp; 2. If an enemy is seen follow that enemy.<br /><br />&nbsp;&nbsp;&nbsp; 3. Otherwise wonder the map.<br /><br />*/<br /><br />proc(mainControl(2),<br /><br />%&nbsp;&nbsp;&nbsp; [goto(home), sleep]<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; prioritized_interrupts(<br /><br />&nbsp;&nbsp;&nbsp; [<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(contactedEnemy=glen, attack( _, [target,glen], _)),<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(seenEnemy=glen, follow(_, [target,glen])),<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(true, pi(start, pi(location, [relocate(start,location)])))<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; ]) % end of interupts<br /><br />).<br /></code></pre><br /><br />prioritize interrupts chooses the interrupt for which its condition is true first.<br /><br /><pre class="prettyprint"><code class="language-bash"><br />% Controller for the Wumpus:<br /><br />%&nbsp;&nbsp; &nbsp;1. If agent knows where the wumpus is, she is in line with it and<br /><br />%&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; the wumpus may be alive, then aim to wumpus and shoot arrow<br /><br />%&nbsp;&nbsp; &nbsp;2. If agent knows that there is gold in the current square, pick it up<br /><br />%&nbsp;&nbsp; &nbsp;3. Otherwise: sense everything and take a randomWalk<br /><br />proc(mainControl(3),<br /><br />&nbsp;&nbsp; prioritized_interrupts(<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [interrupt([dir], and(aliveWumpus=true,<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; in_line(locRobot,dir,locWumpus)), [shoot(dir)] ),<br /><br />&nbsp;&nbsp;&nbsp; &nbsp; interrupt(isGold(locRobot)=true, [pickGold]),<br /><br />&nbsp;&nbsp;&nbsp; &nbsp; interrupt(inDungeon=true, [smell,senseBreeze,senseGold,<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;wndet(newRandomWalk, [goto(loc(1,1)),climb])])<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ])&nbsp; % END OF INTERRUPTS<br /><br />).<br /><br /><br /><br /><br /><br />proc(mainControl(4),<br /><br />&nbsp;&nbsp;&nbsp; while(alive, searchForEnemy(glen))<br /><br />).<br /><br /><br /><br /><br /><br />proc(mainControl(9),<br /><br />%&nbsp;&nbsp;&nbsp; [goto(home), sleep]<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; prioritized_interrupts( <br /><br />&nbsp;&nbsp;&nbsp; [<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(and(role=capdef, neg(hasenemyflag=false)), defendCapturer),<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(and(role=capdef, some([enemy, friend], and(attacking(enemy, friend)=yes, neg(isEnemy(friend))))), <br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pi(enemy, attack( _, [target, enemy], _))),<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(and(role=capdef, neg(seeEnemy=false)),&nbsp;&nbsp;&nbsp; pi(enemy, <br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(bAttackedBy(enemy), <br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; attack( _, [target,enemy], _), <br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; avoidEnemy))),<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; interrupt(role=capdef, startgoto(_, [destination, enemyflag2]))<br /><br />&nbsp;&nbsp;&nbsp; ]%,<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; %if&nbsp; % end of if<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; )% end of while<br /><br />).<br /></code></pre><br /><br /><br />References:<br /><ol><li>http://www.cs.toronto.edu/~alexei/ig-oaa/indigolog.htm</li><li>http://www.cse.yorku.ca/~lesperan/IndiGolog/</li><li>http://sourceforge.net//projects/indigolog/</li></ol><br /><br /><br />